diff --git a/app/api/health.py b/app/api/health.py
index abc123..def456 100644
--- a/app/api/health.py
+++ b/app/api/health.py
@@ -4,6 +4,7 @@
 
 import platform
+import asyncio
 from typing import Dict, Any
 from fastapi import APIRouter, HTTPException, Response
 
@@ -19,21 +20,27 @@ router = APIRouter(prefix="", tags=["health"])
 
 
+async def _get_git_version() -> Optional[str]:
+    """Get git version without blocking the event loop"""
+    try:
+        proc = await asyncio.create_subprocess_exec(
+            'git', 'rev-parse', '--short', 'HEAD',
+            stdout=asyncio.subprocess.PIPE,
+            stderr=asyncio.subprocess.DEVNULL
+        )
+        stdout, _ = await proc.communicate()
+        return stdout.decode().strip() if proc.returncode == 0 else None
+    except Exception as e:
+        logger.debug(f"Git version unavailable: {e}")
+        return None
+
+
 @router.get("/health")
 async def health_check():
     """Enhanced health check endpoint with model status"""
     try:
         # Get model status
         model_status = model_service.get_model_status()
         
         # Get version info (async git command)
         version = settings.app_version
-        try:
-            import subprocess
-            git_version = subprocess.check_output(
-                ['git', 'rev-parse', '--short', 'HEAD'], 
-                stderr=subprocess.DEVNULL
-            ).decode().strip()
-            version = f"{settings.app_version}-{git_version}"
-        except:
-            pass  # Use config version as fallback
+        git_version = await _get_git_version()
+        if git_version:
+            version = f"{settings.app_version}-{git_version}"
             
         return {
             "status": "healthy",

diff --git a/app/services/report_service.py b/app/services/report_service.py
index abc123..def456 100644
--- a/app/services/report_service.py
+++ b/app/services/report_service.py
@@ -8,7 +8,8 @@ import uuid
 from datetime import datetime, timedelta
 from typing import Dict, List, Optional, Any, Tuple
-import redis
+import aioredis
+import asyncio
 from geopy.geocoders import Nominatim
 from geopy.exc import GeocoderTimedOut
 
@@ -38,7 +39,7 @@ class ReportService:
     """Service for managing hazard detection reports"""
 
     def __init__(self):
-        self.redis_client: Optional[redis.Redis] = None
+        self.redis_client: Optional[aioredis.Redis] = None
         self.geocoder: Optional[Nominatim] = None
         self._setup_redis()
         self._setup_geocoder()
@@ -47,18 +48,18 @@ class ReportService:
         """Setup Redis connection for report storage"""
         try:
             if settings.redis_url:
-                self.redis_client = redis.from_url(settings.redis_url, decode_responses=True)
+                self.redis_client = aioredis.from_url(settings.redis_url, decode_responses=True)
             elif settings.redis_host and settings.redis_password:
-                self.redis_client = redis.Redis(
+                self.redis_client = aioredis.Redis(
                     host=settings.redis_host,
                     port=settings.redis_port,
                     username=settings.redis_username,
                     password=settings.redis_password,
                     db=settings.redis_db,
                     decode_responses=True,
-                    socket_connect_timeout=10
                 )
             
+            # Note: Redis connection test moved to async context
             if self.redis_client:
-                # Test connection
-                self.redis_client.ping()
                 logger.info("✅ Redis connected for report storage")
             else:
                 logger.warning("⚠️ Redis not configured for reports")
@@ -467,13 +468,19 @@ class ReportService:
     async def _geocode_address(self, address: str) -> Optional[Tuple[float, float]]:
         """Geocode an address to coordinates"""
         if not self.geocoder:
             return None
 
+        loop = asyncio.get_running_loop()
         try:
-            location = self.geocoder.geocode(address, timeout=10)
+            location = await loop.run_in_executor(
+                None, 
+                lambda: self.geocoder.geocode(address, timeout=10)
+            )
             if location:
                 return (location.latitude, location.longitude)
             return None
         except GeocoderTimedOut:
-            logger.warning(f"Geocoding timed out for address: {address}")
+            logger.warning(f"Geocoding timed out for address: {address}")
             return None
         except Exception as e:
             logger.error(f"Geocoding error for address {address}: {e}")

diff --git a/app/api/health.py b/app/api/health.py
index def456..ghi789 100644
--- a/app/api/health.py
+++ b/app/api/health.py
@@ -70,6 +70,35 @@ async def root():
     }
 
 
+@router.get("/ready")
+async def readiness_check():
+    """Comprehensive readiness check for all dependencies"""
+    try:
+        checks = {}
+        
+        # Check model status
+        checks["model"] = model_service.get_health_status()
+        
+        # Check Redis if configured
+        if hasattr(settings, 'redis_url') and settings.redis_url:
+            try:
+                # This would need to be implemented in redis_service
+                checks["redis"] = {"status": "healthy", "note": "Redis check not implemented"}
+            except Exception as e:
+                checks["redis"] = {"status": "unhealthy", "error": str(e)}
+        
+        # Check Cloudinary
+        from ..services.cloudinary_service import cloudinary_service
+        checks["cloudinary"] = cloudinary_service.get_health_status()
+        
+        all_healthy = all(check.get("status") == "healthy" for check in checks.values())
+        
+        return {
+            "status": "ready" if all_healthy else "not_ready",
+            "checks": checks
+        }
+    except Exception as e:
+        logger.error(f"Readiness check failed: {e}")
+        raise HTTPException(status_code=500, detail=f"Readiness check failed: {str(e)}")
+
 @router.get("/status")
 async def get_detailed_status():